<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests SQLite - U-AUBEN</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            max-width: 800px;
            margin: auto;
        }
        h1 {
            color: #00ff00;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 10px;
        }
        .test-section {
            background: #2a2a2a;
            border: 1px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }
        button {
            background: #00ff00;
            color: #1a1a1a;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
        }
        button:hover {
            background: #00cc00;
        }
        .success {
            color: #00ff00;
        }
        .error {
            color: #ff0000;
        }
        .info {
            color: #00ccff;
        }
        #log {
            background: #0a0a0a;
            border: 1px solid #00ff00;
            padding: 15px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #00ff00;
            padding-left: 10px;
        }
    </style>
</head>
<body>

<h1>üß™ Suite de Tests SQLite - U-AUBEN INVENTORY</h1>

<div class="test-section">
    <h2>1. Tests d'Initialisation</h2>
    <button onclick="testInitDB()">Test Init DB</button>
    <button onclick="testCreateTables()">Test Create Tables</button>
</div>

<div class="test-section">
    <h2>2. Tests CRUD Inventory</h2>
    <button onclick="testInsertProduct()">Test Insert</button>
    <button onclick="testReadProducts()">Test Read</button>
    <button onclick="testUpdateProduct()">Test Update</button>
    <button onclick="testDeleteProduct()">Test Delete</button>
</div>

<div class="test-section">
    <h2>3. Tests Notes</h2>
    <button onclick="testInsertNote()">Test Insert Note</button>
    <button onclick="testReadNotes()">Test Read Notes</button>
</div>

<div class="test-section">
    <h2>4. Tests IA Aube</h2>
    <button onclick="testAubeOffline()">Test Aube Offline</button>
    <button onclick="testInventoryForAI()">Test AI Context</button>
</div>

<div class="test-section">
    <h2>5. Tests de Stress</h2>
    <button onclick="testBulkInsert()">Test Bulk Insert (100)</button>
    <button onclick="testConcurrentReads()">Test Concurrent Reads</button>
    <button onclick="clearAllData()">üóëÔ∏è Clear All Data</button>
</div>

<div id="log">
    <div class="log-entry info">üìã Logs de test appara√Ætront ici...</div>
</div>

<script type="module">
    // Mock SQLite pour tests en navigateur
    let mockDB = {
        inventory: [],
        notes: [],
        nextInventoryId: 1,
        nextNoteId: 1
    };
    
    // Logger
    function log(message, type = 'info') {
        const logDiv = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log(message);
    }
    
    // Mock DB Functions
    const db = {
        execute: async (sql) => {
            log(`üìù EXECUTE: ${sql}`, 'info');
            return { changes: 0 };
        },
        run: async (sql, params) => {
            log(`üèÉ RUN: ${sql} | PARAMS: ${JSON.stringify(params)}`, 'info');
            
            if (sql.includes('INSERT INTO inventory')) {
                mockDB.inventory.push({
                    id: mockDB.nextInventoryId++,
                    product_name: params[0],
                    quantity: params[1],
                    unit: params[2],
                    last_updated: new Date().toISOString()
                });
                log(`‚úÖ Produit ajout√©: ID ${mockDB.nextInventoryId - 1}`, 'success');
            }
            
            if (sql.includes('INSERT INTO notes')) {
                mockDB.notes.push({
                    id: mockDB.nextNoteId++,
                    content: params[0],
                    category: params[1],
                    date: new Date().toISOString()
                });
                log(`‚úÖ Note ajout√©e: ID ${mockDB.nextNoteId - 1}`, 'success');
            }
            
            if (sql.includes('DELETE FROM inventory')) {
                const idToDelete = params[0];
                mockDB.inventory = mockDB.inventory.filter(item => item.id !== idToDelete);
                log(`üóëÔ∏è Produit supprim√©: ID ${idToDelete}`, 'success');
            }
            
            if (sql.includes('UPDATE inventory')) {
                const [newQty, id] = params;
                const item = mockDB.inventory.find(i => i.id === id);
                if (item) {
                    item.quantity = newQty;
                    item.last_updated = new Date().toISOString();
                    log(`üìù Produit mis √† jour: ID ${id}, Qty ${newQty}`, 'success');
                }
            }
            
            return { changes: 1 };
        },
        query: async (sql, params = []) => {
            log(`üîç QUERY: ${sql}`, 'info');
            
            if (sql.includes('SELECT * FROM inventory')) {
                return { values: mockDB.inventory };
            }
            
            if (sql.includes('SELECT * FROM notes')) {
                return { values: mockDB.notes };
            }
            
            if (sql.includes('COUNT(*)')) {
                return { 
                    values: [{ 
                        total: mockDB.inventory.length 
                    }] 
                };
            }
            
            return { values: [] };
        }
    };
    
    // === TESTS ===
    
    window.testInitDB = async function() {
        log('üöÄ Test: Initialisation de la base de donn√©es', 'info');
        try {
            log('Creating SQLite connection...', 'info');
            log('Opening database...', 'info');
            await new Promise(resolve => setTimeout(resolve, 500));
            log('‚úÖ Base de donn√©es initialis√©e avec succ√®s', 'success');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testCreateTables = async function() {
        log('üìã Test: Cr√©ation des tables', 'info');
        try {
            await db.execute(`CREATE TABLE IF NOT EXISTS inventory (...)`);
            await db.execute(`CREATE TABLE IF NOT EXISTS notes (...)`);
            log('‚úÖ Tables cr√©√©es avec succ√®s', 'success');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testInsertProduct = async function() {
        log('‚ûï Test: Insertion d\'un produit', 'info');
        try {
            await db.run(
                `INSERT INTO inventory (product_name, quantity, unit) VALUES (?, ?, ?)`,
                ['Colis A', 50, 'pcs']
            );
            log('‚úÖ Produit ins√©r√© avec succ√®s', 'success');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testReadProducts = async function() {
        log('üìñ Test: Lecture des produits', 'info');
        try {
            const result = await db.query('SELECT * FROM inventory');
            log(`üì¶ Produits trouv√©s: ${result.values.length}`, 'success');
            result.values.forEach(item => {
                log(`   - ${item.product_name}: ${item.quantity} ${item.unit}`, 'info');
            });
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testUpdateProduct = async function() {
        log('‚úèÔ∏è Test: Mise √† jour d\'un produit', 'info');
        try {
            if (mockDB.inventory.length === 0) {
                log('‚ö†Ô∏è Aucun produit √† mettre √† jour. Insertion d\'abord...', 'info');
                await testInsertProduct();
            }
            
            const firstId = mockDB.inventory[0].id;
            await db.run(
                `UPDATE inventory SET quantity = ? WHERE id = ?`,
                [75, firstId]
            );
            log('‚úÖ Produit mis √† jour avec succ√®s', 'success');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testDeleteProduct = async function() {
        log('üóëÔ∏è Test: Suppression d\'un produit', 'info');
        try {
            if (mockDB.inventory.length === 0) {
                log('‚ö†Ô∏è Aucun produit √† supprimer', 'info');
                return;
            }
            
            const firstId = mockDB.inventory[0].id;
            await db.run('DELETE FROM inventory WHERE id = ?', [firstId]);
            log('‚úÖ Produit supprim√© avec succ√®s', 'success');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testInsertNote = async function() {
        log('üìù Test: Insertion d\'une note', 'info');
        try {
            await db.run(
                `INSERT INTO notes (content, category) VALUES (?, ?)`,
                ['R√©union demain √† 10h', 'Rappel']
            );
            log('‚úÖ Note ins√©r√©e avec succ√®s', 'success');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testReadNotes = async function() {
        log('üìñ Test: Lecture des notes', 'info');
        try {
            const result = await db.query('SELECT * FROM notes');
            log(`üìù Notes trouv√©es: ${result.values.length}`, 'success');
            result.values.forEach(note => {
                log(`   - [${note.category}] ${note.content}`, 'info');
            });
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testAubeOffline = async function() {
        log('ü§ñ Test: Aube en mode Offline', 'info');
        try {
            const message = "Combien de Colis A ?";
            log(`User: ${message}`, 'info');
            
            const result = await db.query('SELECT * FROM inventory');
            const productMatch = result.values.find(item => 
                message.toLowerCase().includes(item.product_name.toLowerCase())
            );
            
            if (productMatch) {
                const response = `üîµ Aube (Offline): Il reste ${productMatch.quantity} ${productMatch.unit} de ${productMatch.product_name}.`;
                log(response, 'success');
            } else {
                log('üîµ Aube (Offline): Produit non trouv√©', 'info');
            }
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testInventoryForAI = async function() {
        log('üß† Test: Contexte pour IA', 'info');
        try {
            const result = await db.query('SELECT * FROM inventory');
            if (result.values.length === 0) {
                log('L\'inventaire est vide', 'info');
                return;
            }
            
            const context = result.values.map(item => 
                `${item.product_name}: ${item.quantity} ${item.unit}`
            ).join(', ');
            
            log(`üìä Contexte IA: ${context}`, 'success');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testBulkInsert = async function() {
        log('‚ö° Test: Insertion en masse (100 produits)', 'info');
        const startTime = Date.now();
        
        try {
            for (let i = 1; i <= 100; i++) {
                await db.run(
                    `INSERT INTO inventory (product_name, quantity, unit) VALUES (?, ?, ?)`,
                    [`Produit ${i}`, Math.floor(Math.random() * 100) + 1, 'pcs']
                );
            }
            
            const duration = Date.now() - startTime;
            log(`‚úÖ 100 produits ins√©r√©s en ${duration}ms`, 'success');
            log(`‚è±Ô∏è Moyenne: ${(duration / 100).toFixed(2)}ms par insertion`, 'info');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.testConcurrentReads = async function() {
        log('üîÑ Test: Lectures concurrentes', 'info');
        const startTime = Date.now();
        
        try {
            const promises = [];
            for (let i = 0; i < 50; i++) {
                promises.push(db.query('SELECT * FROM inventory'));
            }
            
            await Promise.all(promises);
            const duration = Date.now() - startTime;
            log(`‚úÖ 50 lectures concurrentes en ${duration}ms`, 'success');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    window.clearAllData = async function() {
        log('üóëÔ∏è Nettoyage de toutes les donn√©es', 'info');
        try {
            mockDB.inventory = [];
            mockDB.notes = [];
            mockDB.nextInventoryId = 1;
            mockDB.nextNoteId = 1;
            log('‚úÖ Toutes les donn√©es ont √©t√© effac√©es', 'success');
        } catch (error) {
            log(`‚ùå Erreur: ${error.message}`, 'error');
        }
    };
    
    // Initial message
    log('üéØ Suite de tests charg√©e. Cliquez sur les boutons pour tester.', 'success');
    log('‚ÑπÔ∏è  Note: Ces tests utilisent un mock de SQLite pour le navigateur', 'info');
</script>

</body>
</html>
